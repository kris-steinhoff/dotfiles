## to use, include this line in your .bashrc file
#
# test -e ${HOME}/.bashrc_common && source ${HOME}/.bashrc_common
#

if [ "${BASH-no}" != "no" ]; then
	[ -r /etc/bashrc ] && . /etc/bashrc
fi

export PROMPT_COMMAND=bigPrompt

export VISUAL="vim"
export EDITOR="vim"
export CVS_RSH="ssh"

export PATH=${HOME}/bin:${PATH}

export HISTIGNORE=exit:logout
export HISTFILESIZE=1000

# alias cd=pushd
# alias bd=popd

# {{{ Define colors
COLOR_PROMPT_RED="\[\e[31m\]"
COLOR_PROMPT_GREEN="\[\e[32m\]"
COLOR_PROMPT_YELLOW="\[\e[33m\]"
COLOR_PROMPT_BLUE="\[\e[34m\]"
COLOR_PROMPT_MAGENTA="\[\e[35m\]"
COLOR_PROMPT_CYAN="\[\e[36m\]"

COLOR_PROMPT_RED_BOLD="\[\e[31;0m\]"
COLOR_PROMPT_GREEN_BOLD="\[\e[32;0m\]"
COLOR_PROMPT_YELLOW_BOLD="\[\e[33;0m\]"
COLOR_PROMPT_BLUE_BOLD="\[\e[34;0m\]"
COLOR_PROMPT_MAGENTA_BOLD="\[\e[35;0m\]"
COLOR_PROMPT_CYAN_BOLD="\[\e[36;0m\]"

COLOR_PROMPT_NONE="\[\e[0m\]"

COLOR_RED="\e[31m"
COLOR_GREEN="\e[32m"
COLOR_YELLOW="\e[33m"
COLOR_BLUE="\e[34m"
COLOR_MAGENTA="\e[35m"
COLOR_CYAN="\e[36m"

COLOR_RED_BOLD="\e[31;0m"
COLOR_GREEN_BOLD="\e[32;0m"
COLOR_YELLOW_BOLD="\e[33;0m"
COLOR_BLUE_BOLD="\e[34;0m"
COLOR_MAGENTA_BOLD="\e[35;0m"
COLOR_CYAN_BOLD="\e[36;0m"

COLOR_NONE="\e[0m"
# }}} END Define colors

# {{{ Operating System specific settings
case `uname` in
    Darwin)
        # Sets up colorized ls
        export TERM=xterm-color
        export CLICOLOR=true
        export LSCOLORS=gxfxcxdxbxegedabagacad

        alias l='ls'
        alias ll='ls -lah'
        alias ttop='top -ocpu -R -F -n30'

        export HOST=`hostname -s`
        ;;
    Linux)
        export LS_COLORS="no=00:fi=00:di=00;36:ln=00;35:pi=40;33:so=00;35:do=00;35:bd=40;33;00:cd=40;33;00:or=40;31;00:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=00;32:"
        alias ls='ls --color'
        alias l='ls -F'
        alias ll='ls -Flah'

        export HOST=${HOSTNAME}
    ;;
esac
# }}} END Operating System specific settings

# {{{ Prompts
if [ $UID -eq 0 ]; then
    export PROMPT_CHAR="#"
else
    export PROMPT_CHAR="$"
fi

tinyPrompt()
{
    PREV_RET_VAL=$?;

    PS1=""

    if test $PREV_RET_VAL -eq 0
    then
        PS1="${PS1}${COLOR_PROMPT_GREEN}${PROMPT_CHAR}${COLOR_PROMPT_NONE} "
    else
        PS1="${PS1}${COLOR_PROMPT_RED}${PREV_RET_VAL} ${PROMPT_CHAR}${COLOR_PROMPT_NONE} "
    fi
}

bigPrompt()
{
    PREV_RET_VAL=$?;
    PS1=""

        PS1="${PS1}${COLOR_PROMPT_YELLOW}\u${COLOR_PROMPT_NONE}"

        PS1="${PS1}@${COLOR_PROMPT_RED}\h${COLOR_PROMPT_NONE}:${COLOR_PROMPT_YELLOW}\w${COLOR_PROMPT_NONE}"

        if test $PREV_RET_VAL -eq 0
        then
            PS1="${PS1}\n${COLOR_PROMPT_GREEN}${PROMPT_CHAR}${COLOR_PROMPT_NONE} "
        else
            PS1="${PS1}\n${COLOR_PROMPT_RED}[${PREV_RET_VAL}] ${PROMPT_CHAR}${COLOR_PROMPT_NONE} "
        fi
}

scmPrompt()
{
    PREV_RET_VAL=$?;
    test -r ${HOME}/.ssh/agent-env && source ${HOME}/.ssh/agent-env 1> /dev/null

    PS1=""

        PS1="${PS1}${COLOR_PROMPT_YELLOW}\u${COLOR_PROMPT_NONE}"
        PS1="${PS1}@${COLOR_PROMPT_RED}\h${COLOR_PROMPT_NONE}:${COLOR_PROMPT_YELLOW}\w${COLOR_PROMPT_NONE} ${COLOR_PROMPT_CYAN}\t${COLOR_NONE}"

        git branch &> /dev/null; rc=$?;
        if [ $rc -eq 0 ]; then
            BRANCH=`git branch --no-color 2> /dev/null | grep ^\* | sed s/\*\ //g`
            if [ "x${BRANCH}" = "xmaster" ]; then
                INFO=""
            elif [ "x${BRANCH}" = "x" ]; then
                INFO="(no branch found)"
            else
                INFO="${BRANCH}:"
            fi
            COMMIT=`git log -1 2> /dev/null | head -1 | awk '{print $2}' | cut -c 1-7`
            INFO=${INFO}${COMMIT};
            git status 2> /dev/null | tail -n1 | grep 'working directory clean' &> /dev/null; rc=$?
            if [ $rc -eq 0 ]; then
                STATE_COLOR=${COLOR_PROMPT_GREEN}
            else
                STATE_COLOR=${COLOR_PROMPT_RED}
            fi
            PS1="${PS1} ${STATE_COLOR}[${INFO}]${COLOR_PROMPT_NONE}"
        fi

        svn info &> /dev/null; rc=$?
        if [ $rc -eq 0 ]; then
            REV=`svn info | grep '^Revision: '| awk -F': ' '{print $2}'`
            lines=`svn st | wc | awk '{print $1}'`
            if [ $lines -eq 0 ]; then
                STATE_COLOR=${COLOR_PROMPT_GREEN}
            else
                STATE_COLOR=${COLOR_PROMPT_RED}
            fi
            PS1="${PS1} ${STATE_COLOR}[${REV}]${COLOR_PROMPT_NONE}"
        fi

        if test $PREV_RET_VAL -eq 0
        then
            PS1="${PS1}\n${COLOR_PROMPT_GREEN}${PROMPT_CHAR}${COLOR_PROMPT_NONE} "
        else
            PS1="${PS1}\n${COLOR_PROMPT_RED}[${PREV_RET_VAL}] ${PROMPT_CHAR}${COLOR_PROMPT_NONE} "
        fi
}

hugePrompt()
{
    PREV_RET_VAL=$?;

    PS1=""

        if test "$USER" != "root"
            then
                PS1="${PS1}${COLOR_PROMPT_YELLOW}\u${COLOR_PROMPT_NONE}"
        else
            PS1="${PS1}${COLOR_PROMPT_RED}\u${COLOR_PROMPT_NONE}"
                fi

                PS1="${PS1}@${COLOR_PROMPT_RED}\h${COLOR_PROMPT_NONE}:${COLOR_PROMPT_YELLOW}\w ${COLOR_PROMPT_CYAN}  \d \t ${COLOR_PROMPT_MAGENTA}\! ${COLOR_PROMPT_NONE}"

            if test $PREV_RET_VAL -eq 0
                then
                    PS1="${PS1}\n${COLOR_PROMPT_GREEN}${PROMPT_CHAR}${COLOR_PROMPT_NONE} "
            else
                PS1="${PS1}\n${COLOR_PROMPT_RED}[${PREV_RET_VAL}] ${PROMPT_CHAR}${COLOR_PROMPT_NONE} "
            fi
}

PS2="${COLOR_PROMPT_GREEN}>${COLOR_PROMPT_NONE} "
# }}} END Prompts

# {{{ SSH helpers functions
ssh-agent-start () {
    TMP=`mktemp /tmp/ssh-start.XXXX`

    ssh-add -l >& ${TMP}; rc=$?

    if [ $rc = 0 ]; then
        echo The ssh-agent is already running.
        cat ${TMP}
    elif [ $rc = 1 ]; then
        echo The ssh-agent is already running.
        cat ${TMP}
        ssh-add
    else
        ssh-agent -t 86400 > ~/.ssh/agent-env
        source ~/.ssh/agent-env
        echo The ssh-agent has been started.
        ssh-add
    fi

    rm ${TMP}
}

ssh-agent-grab-env () {
    SSHVARS="SSH_CLIENT"

    for x in ${SSHVARS} ; do
        (eval echo $x=\$$x) | sed 's/=/="/' | sed 's/$/"/' | sed 's/^/export /'
    done 1>~/.ssh/agent-env
}

ssh-agent-fix () {
    AGENT_ENV=~/.ssh/agent-env

    test -r ${AGENT_ENV} && source ${AGENT_ENV}
}

ssh-agent-fix
alias sshfix=ssh-agent-fix
# }}} END SSH helpers functions

# {{{ Misc helper functions
creds () {
    if [ "x${1}" = "x-k" ]; then
        kdestroy
        ssh-agent -k
    fi

    klist -5 || kinit -f -l 10h
    echo ""
    ssh-add -l || ssh-agent-start
}

attach ()
{
    ssh-agent-grab-env

    name=${*}
    file=${HOME}/.screenrcs/${name}

    if [ "x$name" = "x" ]; then
        screen -ls
    else
        SCREENSESSION=$name screen -ls ${name} | head -1 | grep '^No Sockets found' > /dev/null; rc=$?
        if [ $rc -ne 0 ]; then
            titleset $USER@`hostname` $name
            SCREENSESSION=$name screen -dr $name
            titleset
        else
            res=`prompt "Socket $name not found. Start? [Y/n]" Y`
            if [ "$res" = "Y" -o "$res" = "y" ]; then
                if [ ! -e "${file}" ]; then
                    res=`prompt "Config file for $name not found. Create? [y/N]" N`
                    if [ "$res" = "Y" -o "$res" = "y" ]; then
                        if [ ! -d "`dirname $file`" ]; then
                            mkdir "`dirname $file`"
                        fi
                        echo "
source ${HOME}/.screenrc
screen -t bash 0 bash
screen -t bash 1 bash
select 0
        " > ${file}
                        ${VISUAL} ${file}
                        SCREENSESSION=$name screen -S $name -c ${file}
                    else
                        SCREENSESSION=$name screen -S $name
                    fi
                else
                    SCREENSESSION=$name screen -S $name -c ${file}
                fi
            fi
        fi
    fi
}

_attach_complete ()
{
    screens=`screen -ls | while read s dump; do echo $s | grep '[0-9]\..*' &> /dev/null; rc=$?; if [ ${rc} -eq 0 ]; then echo $s | awk -F. '{ print $2 }'; fi; done`
    local curw
    COMPREPLY=()
    curw=${COMP_WORDS[COMP_CWORD]}
    COMPREPLY=($(compgen -W "${screens}" -- $curw))
    return 0
}

complete -F _attach_complete attach

prompt ()
{
    prompt=${1}
    default=${2}

    read -p "$prompt " prompt_name

    if [ "x$prompt_name" != "x" ]; then
        echo $prompt_name
    else
        echo $default
    fi
}

titleset()
{
    if [ "${*}" ]; then
        TITLE="${*}"
    else
        if [ ! ${HOST} ]; then
           HOST=`hostname`
        fi
        TITLE=${USER}@${HOST}
    fi

    echo -ne "\033]0;${TITLE}\007"
}
# }}} END Misc helper functions
